State 0:
## Known stack suffix:
##
## LR(1) items:
grammar' -> . grammar [ # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 2
-- On LID shift to state 3
-- On symbol shift to state 4
-- On separated_nonempty_list(nonempty_list(NEWLINE),old_rule) shift to state 12
-- On old_rule shift to state 13
-- On grammar shift to state 18
## Reductions:

State 1:
## Known stack suffix:
## UID
## LR(1) items:
symbol -> UID . [ UID QID NEWLINE LID COLONCOLONEQUAL BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LID COLONCOLONEQUAL BAR #
--   reduce production symbol -> UID
** End-of-stream conflict on UID QID NEWLINE LID COLONCOLONEQUAL BAR
**   There is a tension between
**   (1) reducing production symbol -> UID
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 2:
## Known stack suffix:
## QID
## LR(1) items:
symbol -> QID . [ UID QID NEWLINE LID COLONCOLONEQUAL BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LID COLONCOLONEQUAL BAR #
--   reduce production symbol -> QID
** End-of-stream conflict on UID QID NEWLINE LID COLONCOLONEQUAL BAR
**   There is a tension between
**   (1) reducing production symbol -> QID
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 3:
## Known stack suffix:
## LID
## LR(1) items:
symbol -> LID . [ UID QID NEWLINE LID COLONCOLONEQUAL BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LID COLONCOLONEQUAL BAR #
--   reduce production symbol -> LID
** End-of-stream conflict on UID QID NEWLINE LID COLONCOLONEQUAL BAR
**   There is a tension between
**   (1) reducing production symbol -> LID
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 4:
## Known stack suffix:
## symbol
## LR(1) items:
old_rule -> symbol . COLONCOLONEQUAL separated_nonempty_list(BAR,nonempty_list(symbol)) [ NEWLINE # ]
## Transitions:
-- On COLONCOLONEQUAL shift to state 5
## Reductions:

State 5:
## Known stack suffix:
## symbol COLONCOLONEQUAL
## LR(1) items:
old_rule -> symbol COLONCOLONEQUAL . separated_nonempty_list(BAR,nonempty_list(symbol)) [ NEWLINE # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 2
-- On LID shift to state 3
-- On symbol shift to state 6
-- On separated_nonempty_list(BAR,nonempty_list(symbol)) shift to state 8
-- On nonempty_list(symbol) shift to state 9
## Reductions:

State 6:
## Known stack suffix:
## symbol
## LR(1) items:
nonempty_list(symbol) -> symbol . [ NEWLINE BAR # ]
nonempty_list(symbol) -> symbol . nonempty_list(symbol) [ NEWLINE BAR # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 2
-- On LID shift to state 3
-- On symbol shift to state 6
-- On nonempty_list(symbol) shift to state 7
## Reductions:
-- On NEWLINE BAR #
--   reduce production nonempty_list(symbol) -> symbol
** End-of-stream conflict on UID QID NEWLINE LID BAR
**   There is a tension between
**   (1) reducing production nonempty_list(symbol) -> symbol
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 7:
## Known stack suffix:
## symbol nonempty_list(symbol)
## LR(1) items:
nonempty_list(symbol) -> symbol nonempty_list(symbol) . [ NEWLINE BAR # ]
## Transitions:
## Reductions:
-- On NEWLINE BAR #
--   reduce production nonempty_list(symbol) -> symbol nonempty_list(symbol)
** End-of-stream conflict on NEWLINE BAR
**   There is a tension between
**   (1) reducing production nonempty_list(symbol) -> symbol nonempty_list(symbol)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 8:
## Known stack suffix:
## symbol COLONCOLONEQUAL separated_nonempty_list(BAR,nonempty_list(symbol))
## LR(1) items:
old_rule -> symbol COLONCOLONEQUAL separated_nonempty_list(BAR,nonempty_list(symbol)) . [ NEWLINE # ]
## Transitions:
## Reductions:
-- On NEWLINE #
--   reduce production old_rule -> symbol COLONCOLONEQUAL separated_nonempty_list(BAR,nonempty_list(symbol))
** End-of-stream conflict on NEWLINE
**   There is a tension between
**   (1) reducing production old_rule -> symbol COLONCOLONEQUAL separated_nonempty_list(BAR,nonempty_list(symbol))
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 9:
## Known stack suffix:
## nonempty_list(symbol)
## LR(1) items:
separated_nonempty_list(BAR,nonempty_list(symbol)) -> nonempty_list(symbol) . [ NEWLINE # ]
separated_nonempty_list(BAR,nonempty_list(symbol)) -> nonempty_list(symbol) . BAR separated_nonempty_list(BAR,nonempty_list(symbol)) [ NEWLINE # ]
## Transitions:
-- On BAR shift to state 10
## Reductions:
-- On NEWLINE #
--   reduce production separated_nonempty_list(BAR,nonempty_list(symbol)) -> nonempty_list(symbol)
** End-of-stream conflict on NEWLINE BAR
**   There is a tension between
**   (1) reducing production separated_nonempty_list(BAR,nonempty_list(symbol)) -> nonempty_list(symbol)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 10:
## Known stack suffix:
## nonempty_list(symbol) BAR
## LR(1) items:
separated_nonempty_list(BAR,nonempty_list(symbol)) -> nonempty_list(symbol) BAR . separated_nonempty_list(BAR,nonempty_list(symbol)) [ NEWLINE # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 2
-- On LID shift to state 3
-- On symbol shift to state 6
-- On separated_nonempty_list(BAR,nonempty_list(symbol)) shift to state 11
-- On nonempty_list(symbol) shift to state 9
## Reductions:

State 11:
## Known stack suffix:
## nonempty_list(symbol) BAR separated_nonempty_list(BAR,nonempty_list(symbol))
## LR(1) items:
separated_nonempty_list(BAR,nonempty_list(symbol)) -> nonempty_list(symbol) BAR separated_nonempty_list(BAR,nonempty_list(symbol)) . [ NEWLINE # ]
## Transitions:
## Reductions:
-- On NEWLINE #
--   reduce production separated_nonempty_list(BAR,nonempty_list(symbol)) -> nonempty_list(symbol) BAR separated_nonempty_list(BAR,nonempty_list(symbol))
** End-of-stream conflict on NEWLINE
**   There is a tension between
**   (1) reducing production separated_nonempty_list(BAR,nonempty_list(symbol)) -> nonempty_list(symbol) BAR separated_nonempty_list(BAR,nonempty_list(symbol))
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 12:
## Known stack suffix:
## separated_nonempty_list(nonempty_list(NEWLINE),old_rule)
## LR(1) items:
grammar -> separated_nonempty_list(nonempty_list(NEWLINE),old_rule) . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production grammar -> separated_nonempty_list(nonempty_list(NEWLINE),old_rule)

State 13:
## Known stack suffix:
## old_rule
## LR(1) items:
separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule . [ # ]
separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule . nonempty_list(NEWLINE) separated_nonempty_list(nonempty_list(NEWLINE),old_rule) [ # ]
## Transitions:
-- On NEWLINE shift to state 14
-- On nonempty_list(NEWLINE) shift to state 16
## Reductions:
-- On #
--   reduce production separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule
** End-of-stream conflict on NEWLINE
**   There is a tension between
**   (1) reducing production separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 14:
## Known stack suffix:
## NEWLINE
## LR(1) items:
nonempty_list(NEWLINE) -> NEWLINE . [ UID QID LID ]
nonempty_list(NEWLINE) -> NEWLINE . nonempty_list(NEWLINE) [ UID QID LID ]
## Transitions:
-- On NEWLINE shift to state 14
-- On nonempty_list(NEWLINE) shift to state 15
## Reductions:
-- On UID QID LID
--   reduce production nonempty_list(NEWLINE) -> NEWLINE

State 15:
## Known stack suffix:
## NEWLINE nonempty_list(NEWLINE)
## LR(1) items:
nonempty_list(NEWLINE) -> NEWLINE nonempty_list(NEWLINE) . [ UID QID LID ]
## Transitions:
## Reductions:
-- On UID QID LID
--   reduce production nonempty_list(NEWLINE) -> NEWLINE nonempty_list(NEWLINE)

State 16:
## Known stack suffix:
## old_rule nonempty_list(NEWLINE)
## LR(1) items:
separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule nonempty_list(NEWLINE) . separated_nonempty_list(nonempty_list(NEWLINE),old_rule) [ # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 2
-- On LID shift to state 3
-- On symbol shift to state 4
-- On separated_nonempty_list(nonempty_list(NEWLINE),old_rule) shift to state 17
-- On old_rule shift to state 13
## Reductions:

State 17:
## Known stack suffix:
## old_rule nonempty_list(NEWLINE) separated_nonempty_list(nonempty_list(NEWLINE),old_rule)
## LR(1) items:
separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule nonempty_list(NEWLINE) separated_nonempty_list(nonempty_list(NEWLINE),old_rule) . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule nonempty_list(NEWLINE) separated_nonempty_list(nonempty_list(NEWLINE),old_rule)

State 18:
## Known stack suffix:
## grammar
## LR(1) items:
grammar' -> grammar . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept grammar

