State 0:
## Known stack suffix:
##
## LR(1) items:
grammar' -> . grammar [ # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 2
-- On LID shift to state 3
-- On symbol shift to state 4
-- On separated_nonempty_list(nonempty_list(NEWLINE),old_rule) shift to state 31
-- On old_rule shift to state 32
-- On grammar shift to state 37
## Reductions:

State 1:
## Known stack suffix:
## UID
## LR(1) items:
symbol -> UID . [ UID QID NEWLINE LPAREN LID COLONCOLONEQUAL BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LPAREN LID COLONCOLONEQUAL BAR #
--   reduce production symbol -> UID
** End-of-stream conflict on UID QID NEWLINE LPAREN LID COLONCOLONEQUAL BAR
**   There is a tension between
**   (1) reducing production symbol -> UID
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 2:
## Known stack suffix:
## QID
## LR(1) items:
symbol -> QID . [ COLONCOLONEQUAL ]
## Transitions:
## Reductions:
-- On COLONCOLONEQUAL
--   reduce production symbol -> QID

State 3:
## Known stack suffix:
## LID
## LR(1) items:
symbol -> LID . [ COLONCOLONEQUAL ]
## Transitions:
## Reductions:
-- On COLONCOLONEQUAL
--   reduce production symbol -> LID

State 4:
## Known stack suffix:
## symbol
## LR(1) items:
old_rule -> symbol . COLONCOLONEQUAL optional_bar separated_nonempty_list(BAR,production_group) [ NEWLINE # ]
## Transitions:
-- On COLONCOLONEQUAL shift to state 5
## Reductions:

State 5:
## Known stack suffix:
## symbol COLONCOLONEQUAL
## LR(1) items:
old_rule -> symbol COLONCOLONEQUAL . optional_bar separated_nonempty_list(BAR,production_group) [ NEWLINE # ]
## Transitions:
-- On BAR shift to state 6
-- On optional_bar shift to state 7
## Reductions:
-- On UID QID NEWLINE LPAREN LID #
--   reduce production optional_bar ->
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production optional_bar ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 6:
## Known stack suffix:
## BAR
## LR(1) items:
optional_bar -> BAR . [ UID QID NEWLINE LPAREN LID BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LPAREN LID BAR #
--   reduce production optional_bar -> BAR
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production optional_bar -> BAR
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 7:
## Known stack suffix:
## symbol COLONCOLONEQUAL optional_bar
## LR(1) items:
old_rule -> symbol COLONCOLONEQUAL optional_bar . separated_nonempty_list(BAR,production_group) [ NEWLINE # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 8
-- On LPAREN shift to state 9
-- On LID shift to state 16
-- On symbol shift to state 17
-- On separated_nonempty_list(BAR,production_group) shift to state 18
-- On separated_nonempty_list(BAR,production) shift to state 19
-- On production_group shift to state 20
-- On production shift to state 23
-- On producer shift to state 26
-- On list(producer) shift to state 30
-- On expression shift to state 28
-- On actual shift to state 29
## Reductions:
-- On NEWLINE BAR #
--   reduce production list(producer) ->
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production list(producer) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 8:
## Known stack suffix:
## QID
## LR(1) items:
expression -> QID . [ UID QID NEWLINE LPAREN LID BAR # ]
symbol -> QID . [ UID QID NEWLINE LPAREN LID BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LPAREN LID BAR #
--   reduce production expression -> QID
-- On UID QID NEWLINE LPAREN LID BAR #
--   reduce production symbol -> QID
** Conflict on UID QID NEWLINE LPAREN LID BAR #
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production expression -> QID
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 9:
## Known stack suffix:
## LPAREN
## LR(1) items:
expression -> LPAREN . list(expression) RPAREN [ UID RPAREN QID NEWLINE LPAREN LID BAR # ]
## Transitions:
-- On QID shift to state 10
-- On LPAREN shift to state 9
-- On LID shift to state 11
-- On list(expression) shift to state 12
-- On expression shift to state 14
## Reductions:
-- On RPAREN
--   reduce production list(expression) ->

State 10:
## Known stack suffix:
## QID
## LR(1) items:
expression -> QID . [ RPAREN QID LPAREN LID ]
## Transitions:
## Reductions:
-- On RPAREN QID LPAREN LID
--   reduce production expression -> QID

State 11:
## Known stack suffix:
## LID
## LR(1) items:
expression -> LID . [ RPAREN QID LPAREN LID ]
## Transitions:
## Reductions:
-- On RPAREN QID LPAREN LID
--   reduce production expression -> LID

State 12:
## Known stack suffix:
## LPAREN list(expression)
## LR(1) items:
expression -> LPAREN list(expression) . RPAREN [ UID RPAREN QID NEWLINE LPAREN LID BAR # ]
## Transitions:
-- On RPAREN shift to state 13
## Reductions:

State 13:
## Known stack suffix:
## LPAREN list(expression) RPAREN
## LR(1) items:
expression -> LPAREN list(expression) RPAREN . [ UID RPAREN QID NEWLINE LPAREN LID BAR # ]
## Transitions:
## Reductions:
-- On UID RPAREN QID NEWLINE LPAREN LID BAR #
--   reduce production expression -> LPAREN list(expression) RPAREN
** End-of-stream conflict on UID RPAREN QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production expression -> LPAREN list(expression) RPAREN
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 14:
## Known stack suffix:
## expression
## LR(1) items:
list(expression) -> expression . list(expression) [ RPAREN ]
## Transitions:
-- On QID shift to state 10
-- On LPAREN shift to state 9
-- On LID shift to state 11
-- On list(expression) shift to state 15
-- On expression shift to state 14
## Reductions:
-- On RPAREN
--   reduce production list(expression) ->

State 15:
## Known stack suffix:
## expression list(expression)
## LR(1) items:
list(expression) -> expression list(expression) . [ RPAREN ]
## Transitions:
## Reductions:
-- On RPAREN
--   reduce production list(expression) -> expression list(expression)

State 16:
## Known stack suffix:
## LID
## LR(1) items:
expression -> LID . [ UID QID NEWLINE LPAREN LID BAR # ]
symbol -> LID . [ UID QID NEWLINE LPAREN LID BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LPAREN LID BAR #
--   reduce production expression -> LID
-- On UID QID NEWLINE LPAREN LID BAR #
--   reduce production symbol -> LID
** Conflict on UID QID NEWLINE LPAREN LID BAR #
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production expression -> LID
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 17:
## Known stack suffix:
## symbol
## LR(1) items:
actual -> symbol . [ UID QID NEWLINE LPAREN LID BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LPAREN LID BAR #
--   reduce production actual -> symbol
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production actual -> symbol
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 18:
## Known stack suffix:
## symbol COLONCOLONEQUAL optional_bar separated_nonempty_list(BAR,production_group)
## LR(1) items:
old_rule -> symbol COLONCOLONEQUAL optional_bar separated_nonempty_list(BAR,production_group) . [ NEWLINE # ]
## Transitions:
## Reductions:
-- On NEWLINE #
--   reduce production old_rule -> symbol COLONCOLONEQUAL optional_bar separated_nonempty_list(BAR,production_group)
** End-of-stream conflict on NEWLINE
**   There is a tension between
**   (1) reducing production old_rule -> symbol COLONCOLONEQUAL optional_bar separated_nonempty_list(BAR,production_group)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 19:
## Known stack suffix:
## separated_nonempty_list(BAR,production)
## LR(1) items:
production_group -> separated_nonempty_list(BAR,production) . [ NEWLINE BAR # ]
## Transitions:
## Reductions:
-- On NEWLINE BAR #
--   reduce production production_group -> separated_nonempty_list(BAR,production)
** End-of-stream conflict on NEWLINE BAR
**   There is a tension between
**   (1) reducing production production_group -> separated_nonempty_list(BAR,production)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 20:
## Known stack suffix:
## production_group
## LR(1) items:
separated_nonempty_list(BAR,production_group) -> production_group . [ NEWLINE # ]
separated_nonempty_list(BAR,production_group) -> production_group . BAR separated_nonempty_list(BAR,production_group) [ NEWLINE # ]
## Transitions:
-- On BAR shift to state 21
## Reductions:
-- On NEWLINE #
--   reduce production separated_nonempty_list(BAR,production_group) -> production_group
** End-of-stream conflict on NEWLINE BAR
**   There is a tension between
**   (1) reducing production separated_nonempty_list(BAR,production_group) -> production_group
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 21:
## Known stack suffix:
## production_group BAR
## LR(1) items:
separated_nonempty_list(BAR,production_group) -> production_group BAR . separated_nonempty_list(BAR,production_group) [ NEWLINE # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 8
-- On LPAREN shift to state 9
-- On LID shift to state 16
-- On symbol shift to state 17
-- On separated_nonempty_list(BAR,production_group) shift to state 22
-- On separated_nonempty_list(BAR,production) shift to state 19
-- On production_group shift to state 20
-- On production shift to state 23
-- On producer shift to state 26
-- On list(producer) shift to state 30
-- On expression shift to state 28
-- On actual shift to state 29
## Reductions:
-- On NEWLINE BAR #
--   reduce production list(producer) ->
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production list(producer) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 22:
## Known stack suffix:
## production_group BAR separated_nonempty_list(BAR,production_group)
## LR(1) items:
separated_nonempty_list(BAR,production_group) -> production_group BAR separated_nonempty_list(BAR,production_group) . [ NEWLINE # ]
## Transitions:
## Reductions:
-- On NEWLINE #
--   reduce production separated_nonempty_list(BAR,production_group) -> production_group BAR separated_nonempty_list(BAR,production_group)
** End-of-stream conflict on NEWLINE
**   There is a tension between
**   (1) reducing production separated_nonempty_list(BAR,production_group) -> production_group BAR separated_nonempty_list(BAR,production_group)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 23:
## Known stack suffix:
## production
## LR(1) items:
separated_nonempty_list(BAR,production) -> production . [ NEWLINE BAR # ]
separated_nonempty_list(BAR,production) -> production . BAR separated_nonempty_list(BAR,production) [ NEWLINE BAR # ]
## Transitions:
-- On BAR shift to state 24
## Reductions:
-- On NEWLINE BAR #
--   reduce production separated_nonempty_list(BAR,production) -> production
** Conflict on BAR
** End-of-stream conflict on NEWLINE BAR
**   There is a tension between
**   (1) reducing production separated_nonempty_list(BAR,production) -> production
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 24:
## Known stack suffix:
## production BAR
## LR(1) items:
separated_nonempty_list(BAR,production) -> production BAR . separated_nonempty_list(BAR,production) [ NEWLINE BAR # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 8
-- On LPAREN shift to state 9
-- On LID shift to state 16
-- On symbol shift to state 17
-- On separated_nonempty_list(BAR,production) shift to state 25
-- On production shift to state 23
-- On producer shift to state 26
-- On list(producer) shift to state 30
-- On expression shift to state 28
-- On actual shift to state 29
## Reductions:
-- On NEWLINE BAR #
--   reduce production list(producer) ->
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production list(producer) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 25:
## Known stack suffix:
## production BAR separated_nonempty_list(BAR,production)
## LR(1) items:
separated_nonempty_list(BAR,production) -> production BAR separated_nonempty_list(BAR,production) . [ NEWLINE BAR # ]
## Transitions:
## Reductions:
-- On NEWLINE BAR #
--   reduce production separated_nonempty_list(BAR,production) -> production BAR separated_nonempty_list(BAR,production)
** End-of-stream conflict on NEWLINE BAR
**   There is a tension between
**   (1) reducing production separated_nonempty_list(BAR,production) -> production BAR separated_nonempty_list(BAR,production)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 26:
## Known stack suffix:
## producer
## LR(1) items:
list(producer) -> producer . list(producer) [ NEWLINE BAR # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 8
-- On LPAREN shift to state 9
-- On LID shift to state 16
-- On symbol shift to state 17
-- On producer shift to state 26
-- On list(producer) shift to state 27
-- On expression shift to state 28
-- On actual shift to state 29
## Reductions:
-- On NEWLINE BAR #
--   reduce production list(producer) ->
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production list(producer) ->
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 27:
## Known stack suffix:
## producer list(producer)
## LR(1) items:
list(producer) -> producer list(producer) . [ NEWLINE BAR # ]
## Transitions:
## Reductions:
-- On NEWLINE BAR #
--   reduce production list(producer) -> producer list(producer)
** End-of-stream conflict on NEWLINE BAR
**   There is a tension between
**   (1) reducing production list(producer) -> producer list(producer)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 28:
## Known stack suffix:
## expression
## LR(1) items:
actual -> expression . [ UID QID NEWLINE LPAREN LID BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LPAREN LID BAR #
--   reduce production actual -> expression
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production actual -> expression
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 29:
## Known stack suffix:
## actual
## LR(1) items:
producer -> actual . [ UID QID NEWLINE LPAREN LID BAR # ]
## Transitions:
## Reductions:
-- On UID QID NEWLINE LPAREN LID BAR #
--   reduce production producer -> actual
** End-of-stream conflict on UID QID NEWLINE LPAREN LID BAR
**   There is a tension between
**   (1) reducing production producer -> actual
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 30:
## Known stack suffix:
## list(producer)
## LR(1) items:
production -> list(producer) . [ NEWLINE BAR # ]
## Transitions:
## Reductions:
-- On NEWLINE BAR #
--   reduce production production -> list(producer)
** End-of-stream conflict on NEWLINE BAR
**   There is a tension between
**   (1) reducing production production -> list(producer)
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 31:
## Known stack suffix:
## separated_nonempty_list(nonempty_list(NEWLINE),old_rule)
## LR(1) items:
grammar -> separated_nonempty_list(nonempty_list(NEWLINE),old_rule) . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production grammar -> separated_nonempty_list(nonempty_list(NEWLINE),old_rule)

State 32:
## Known stack suffix:
## old_rule
## LR(1) items:
separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule . [ # ]
separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule . nonempty_list(NEWLINE) separated_nonempty_list(nonempty_list(NEWLINE),old_rule) [ # ]
## Transitions:
-- On NEWLINE shift to state 33
-- On nonempty_list(NEWLINE) shift to state 35
## Reductions:
-- On #
--   reduce production separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule
** End-of-stream conflict on NEWLINE
**   There is a tension between
**   (1) reducing production separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule
**   without even requesting a lookahead token, and
**   (2) testing whether the lookahead token is a member of the above set.

State 33:
## Known stack suffix:
## NEWLINE
## LR(1) items:
nonempty_list(NEWLINE) -> NEWLINE . [ UID QID LID ]
nonempty_list(NEWLINE) -> NEWLINE . nonempty_list(NEWLINE) [ UID QID LID ]
## Transitions:
-- On NEWLINE shift to state 33
-- On nonempty_list(NEWLINE) shift to state 34
## Reductions:
-- On UID QID LID
--   reduce production nonempty_list(NEWLINE) -> NEWLINE

State 34:
## Known stack suffix:
## NEWLINE nonempty_list(NEWLINE)
## LR(1) items:
nonempty_list(NEWLINE) -> NEWLINE nonempty_list(NEWLINE) . [ UID QID LID ]
## Transitions:
## Reductions:
-- On UID QID LID
--   reduce production nonempty_list(NEWLINE) -> NEWLINE nonempty_list(NEWLINE)

State 35:
## Known stack suffix:
## old_rule nonempty_list(NEWLINE)
## LR(1) items:
separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule nonempty_list(NEWLINE) . separated_nonempty_list(nonempty_list(NEWLINE),old_rule) [ # ]
## Transitions:
-- On UID shift to state 1
-- On QID shift to state 2
-- On LID shift to state 3
-- On symbol shift to state 4
-- On separated_nonempty_list(nonempty_list(NEWLINE),old_rule) shift to state 36
-- On old_rule shift to state 32
## Reductions:

State 36:
## Known stack suffix:
## old_rule nonempty_list(NEWLINE) separated_nonempty_list(nonempty_list(NEWLINE),old_rule)
## LR(1) items:
separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule nonempty_list(NEWLINE) separated_nonempty_list(nonempty_list(NEWLINE),old_rule) . [ # ]
## Transitions:
## Reductions:
-- On #
--   reduce production separated_nonempty_list(nonempty_list(NEWLINE),old_rule) -> old_rule nonempty_list(NEWLINE) separated_nonempty_list(nonempty_list(NEWLINE),old_rule)

State 37:
## Known stack suffix:
## grammar
## LR(1) items:
grammar' -> grammar . [ # ]
## Transitions:
## Reductions:
-- On #
--   accept grammar

